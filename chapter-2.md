# This file will contain main points from Chapter 2 in effective java book 
- ## Consider static factory methods instead of constructors
    - Advantages:
      - One advantage of static factory methods is that, unlike constructors, they have names.
        - Example: [`In Example class `](src/main/java/org/example/Example.java#L3) there is a static method  [`getInstance()`](src/main/java/org/example/Example.java#L12)  which reflects the proper meaning of method, but on other side constructor does not have name like this
      - A second advantage of static factory methods is that, unlike constructors, they are not required to create a new object each time they’re invoked
        - Example: [`In Example class `](src/main/java/org/example/Example.java#L3) there is a static [`INSTANCE`](src/main/java/org/example/Example.java#L4) created, and it a static, it means it will be created once, even we will call  [`getInstance()`](src/main/java/org/example/Example.java#L12) thousands times
      - A third advantage of static factory methods is that, unlike constructors, they can return an object of any subtype of their return type.
        - Example: [`In AnimalFactory class `](src/main/java/org/example/AnimalFactory.java#L25) there is a static method [`getAnimal()`](src/main/java/org/example/AnimalFactory.java#L27) which return subtype based on the input 
      - A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters. 
        - Example: [`In AnimalFactory class `](src/main/java/org/example/AnimalFactory.java#L25) there is a static method [`getAnimal()`](src/main/java/org/example/AnimalFactory.java#L27) which return subtype based on the input
      - A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written.
        - Example  [`In AnimalFactory1 class `](src/main/java/org/example/AnimalFactory1.java#L31) we are getting instance dynamically, if we create a new animal we don`t need to modify factory class  a
    - Limitations
       - The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed.
       - A second shortcoming of static factory methods is that they are hard for programmers to find.

- ## Consider a builder when faced with many constructor parameters
  - Approach: 1 Telescoping constructor.
    - limitation:  the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it
  - Approach: 2 Constructor & setter approach
    - limitation: the JavaBeans pattern precludes the possibility of making a class immutable
  - Approach: 3 Builder pattern approach
    - Advantage: the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters,
- ## Enforce the singleton property with a private constructor or an enum type
  -  Making a class a singleton can make it difficult to test its clients
  -  a single-element enum type is often the best way to implement a singleton
- ## Enforce noninstantiability with a private constructor
  - Attempting to enforce noninstantiability by making a class abstract does not work.
    - a class can be made noninstantiable by including a private constructor:
- ## Prefer dependency injection to hardwiring resources
  - Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.
  - pass the resource into the constructor when creating a new instance.
- ## Avoid creating unnecessary objects
  -  String s = new String("bikini"); // DON'T DO THIS!
  -  While String.matches is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.
  -  Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types
  -   prefer primitives to boxed primitives, and watch out for unintentional autoboxing
- ## Eliminate obsolete object references
  - Nulling out object references should be the exception rather than the norm.
  - whenever a class manages its own memory, the programmer should be alert for memory leaks.
  - Another common source of memory leaks is caches.
  - A third common source of memory leaks is listeners and other callbacks.
- ## Avoid finalizers and cleaners 
  - Finalizers are unpredictable, often dangerous, and generally unnecessary
  - Cleaners are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.
  -  never do anything time-critical in a finalizer or cleaner
  -  never depend on a finalizer or cleaner to update persistent state.
  -  There is a severe performance penalty for using finalizers and cleaners.
  -  Finalizers have a serious security problem: they open your class up to finalizer attacks.
  -  Throwing an exception from a constructor should be sufficient to prevent an object from coming into existence; in the presence of finalizers, it is not.
  -  To protect nonfinal classes from finalizer attacks, write a final finalize method that does nothing.
- ## Prefer try-with-resources to try-finally
  -   


